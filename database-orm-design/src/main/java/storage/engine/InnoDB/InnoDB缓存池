InnoDB底层架构的设计, 三种链表
free链表
flush链表
LRU链表

Buffer Pool: InnoDB在内存中存储Page页的一块区域，默认是128M ===> 可以调优，设置越大越好
Select * from t1 where a=8;
1. 先判断在Buffer Pool(数组)中是否有查找页的数据(16KB)，如果没有，则从内存中加载(复制)page
2. 对于新加载的Page，通过free链表的头控制块，找到添加到的位置

TODO: Buffer Pool空闲区域的管理
free链表: 基结点(做统计，记录信息) --> 控制块 --> 控制块 --> 控制块 ... 有多少个空闲区域，就有多少个空白的Page
1. 对应新添加的page页，从链表的头控制块找到位置，然后删除头控制块
2. 对于新空出来的page位置，从链表的末尾添加新的控制块

TODO: Buffer Pool持久化的设计
flush链表: 基结点(做统计，记录信息) --> 控制块 --> 控制块 ... 有多少个"脏页"就有多少个控制块, 控制块顺序是按照修改时间的顺序
什么时候将修改后的数据重新持久化回磁盘 ? Mysql后台有一个线程，定时持久化"脏页"回磁盘
后台线程该如何判断是否是"脏页" ?       直接在flush链表上面找，持久化之后再删除控制块

TODO: Buffer Pool中淘汰机制
Buffer Pool占满后如何放置新的page ?
LRU链表: 基结点(做统计，记录信息) --> 控制块 --> 控制块 ... 新加入的page应该加到链表头部，被用到的在最前面，尾部是可以删除的
1. LRU(最近最少使用淘汰机制)问题 ?
   Select * from t1; 全表扫描会清除原来Buffer Pool中索所有的热点数据，重新添加查询需要的page，反复清空会造成性能问题
2. LRU解决办法?
   升级版的LRU链表: 5/8存放热点数据区域 + 3/8冷数据区域, 优先淘汰冷数据块中的数据，能够将热数据(之前常用的加载到内存中的)保留下来
3. 什么时候从冷数据区域移动到热数据区域 ?
   如果冷区域中的page上一次被访问与第二次被访问到的时间差>1S，则会将控制块转移到热数据块
   对于全表扫描而言，每一页page的访问时间差是很短，因此只在冷数据区进行操作，不会影响到(原始的)热数据的page
   如果一页page很快被访问，则不视为热数据，虽然可能就是热数据