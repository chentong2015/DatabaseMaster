package storage.engine.design.InnoDB;

public class InnoDBBasic {
    
    // TODO: 为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键 ? ===> 避免使用UUID(非整型，非自增)
    // 1. 因为数据需要通过B+树来组织数据来存储，如果没有设置主键，则会找一列数据不重复的列(列unique唯一)来组织，如果都没有找到则会建一列隐藏列RowId !!
    //    主键索引: 所设置的primary key就是B+树中的key索引
    // 2. 整型: 减少存储的空间，同时比字符串大小比较效率更高
    // 3. 自增: 为了保证有序性，如果要在一个页已经插满的情况下(>16KB)，插入中间值会导致页分裂或者再左平衡，效率降低
    //         如果自增，永远在后面添加元素，不会导致页分裂

    // TODO: InnoDB存储引擎是如何实现读/写/存储，IO交互，双写缓存 ?
    // 1. "Innodb_page_size"页设计作用:
    //    Page(C语言实现)是InnoDB在存储数据的最小基本单位, 默认是16KB，是磁盘读交互(I/O)的数据单位量，用
    //    设计Page是为了减少IO交互的次数，提升性能

    // 2. 如何将InnoDB Page页的数据(16KB)从内存flush到磁盘中 / 操作系统页持久化的最小单位是4KB
    //    一共分4次写，如果在写的过程中OS挂了，造成磁盘中的数据没改完 !!
    //    2.1 同样分四次将16KB先写到DoubleWrite Buffer Files中，进行持久化
    //        如果写的过程中DoubleWrite Buffer，可以通过t1表空间+redo log来恢复原来内存中的page页数据
    //    2.2 如果成功，再分四次写到t1表空间，如果在写的过程中OS挂了
    //        再通过DoubleWrite Buffer中的持久化数据来将数据页写完成
    //    随着磁盘的优化，如果能够支撑16KB原子性的写，则不再需要DoubleWrite Buffer Files

    // 3. InnoDB如何使用Page页(16KB)来存储数据 ?
    //    页目录(索引)  在用户数据区域
    //      1         (1,1,1,1,'a')  <-- 插入一行的数据，根据主键在插入的时候有顺序的存储
    //      4         (4,3,1,1,'d')  <-- 影响插入的性能，提高查询的性能(有序的链表，遍历还是慢)
    //                (8,8,2,1,'f')
    //                ....           <-- 插满之后，再在其中插入，则会导致"分页"

    // 4. Change Buffer插入缓冲区 -> 写缓冲区
    //    在执行update的时候，除了更新page数据页，还需要更新索引页(聚集索引)
    //    存储修改信息"update 语句"，没有直接去更新索引页，没有直接将索引页加载到内存中
    //    当要走索引的时候，需要从磁盘中取索引页，再结合change buffer得到最新的索引数据
    //    将索引页的更新延迟到非用不可的时候，才做更新，以此可以保证update的性能 !!
}
