https://docs.jboss.org/hibernate/orm/
https://github.com/hibernate/hibernate-orm/wiki/Migration-Guides
https://docs.jboss.org/hibernate/orm/6.0/javadocs/deprecated-list.html

TODO. Hibernate(JPA Implementation) 一种JPA标准的实现
1. Mapping from Java classes to database tables(from Java data types to SQL data types)
   将关系型数据库中的行数据映射成一个对象("数据表行" <--> "实体类Entity")
2. Hibernate功能完善，Provides data query and retrieval facilities
3. Hibernate .hbm.xml文件可以作为C++ Class类型映射的文件

TODO. Native Hibernate API两个映射的配置方式
1. hbm.xml mapping 该种方式是比较旧的方式
   - 优点是能够保证POJO的整洁
   - 缺少是将Java Class和映射分开，需要同时维护两个文件，随着项目的增加，hbm.xml文件会非常大
2. Annotations 推荐使用新的方式
   - 只在一个文件配置映射实体和关系，减少hbm映射文件，便于维护
   - 能够在编译时检查错误
   - 兼容Spring Data JPA(包含Hibernate依赖)，注解一致性

TODO. Hibernate(ORM层框架)在优化性能方面做了哪些配置或设计 ?
   - Caching  使用二级缓存
   - Bathing  减少网络请求
   - Fetching 控制fetch数据的量
   - Flushing 刷新同步Context和DB的数据
   - Locking  保证事务的有效性
   - Inverse  关联关系的维护端

-------------------------------------------------------------------------------
Hibernate 3.x 版本的创建
   Configuration configuration = new Configuration().configure();
   SessionFactory sessionFactory = configuration.buildSessionFactory();
   Session session = sessionFactory.openSession();

Hibernate 4.x 版本的创建: 提供属性配置的参数
   Configuration configuration = new Configuration().configure();
   Properties properties = new Properties();
   properties.put(key, value);
   StandardServiceRegistry standardServiceRegistry = new StandardServiceRegistryBuilder()
      .applySettings(properties)
      .build();
   SessionFactory sessionFactory = configuration.buildSessionFactory(standardServiceRegistry);

   // 使用Configuration和DataSource来完整构建
   private void initSessionFactory(Configuration configuration, DataSource dataSource) {
       Thread.currentThread().setContextClassLoader(DataAccessComponent.class.getClassLoader());
       ServiceRegistry serviceRegistry = new ServiceRegistryBuilder()
               .applySettings(configuration.getProperties())
               .applySetting(Environment.DATASOURCE, dataSource)
               .applySetting(Environment.DIALECT_RESOLVERS, CustomDialectResolver.class.getName())
               .buildServiceRegistry();
       try {
           sessionFactory = configuration.buildSessionFactory(serviceRegistry);
       } catch (Exception e) {
           throw new DataAccessException("Unable to connect to Financial Database");
       }
   }

Hibernate 5.x 版本之后的创建: 从元信息中获取Session工厂
   1. 简单方式
    StandardServiceRegistry registry = new StandardServiceRegistryBuilder().configure().build();
    SessionFactory sessionFactory = new MetadataSources(registry).buildMetadata().buildSessionFactory();

   2. 复杂方式: 支持自定义配置Properties, MetadataSources提供丰富的Metadata源数据注入,
    this.bootstrapServiceRegistry = new BootstrapServiceRegistryBuilder().applyClassLoader(classLoader).build();
    this.standardServiceRegistryBuilder = new StandardServiceRegistryBuilder(bootstrapServiceRegistry);
    if (configFile != null) {
       standardServiceRegistryBuilder.configure(configFile);
       properties.putAll(standardServiceRegistryBuilder.getSettings());
    }
    standardServiceRegistryBuilder.applySettings(properties);
    StandardServiceRegistry standardServiceRegistry = standardServiceRegistryBuilder.build();

    MetadataSources metadataSources = new MetadataSources();
    MetadataBuilder metadataBuilder = metadataSources.getMetadataBuilder(standardServiceRegistry);
    for (BasicType murexType : getMurexTypes()) {
       metadataBuilder.applyBasicType(murexType);
    }

    Metadata metadata = metadataBuilder.build();
    SessionFactory sessionFactory1 = metadata.buildSessionFactory();

