package mysql_master.storage_engine;

// TODO: 不同的"存储引擎"底层索引的存储结构有所区别
// 1. 数据库往往是一个比较丰富完整的系统, 提供了SQL查询语言，事务和水平扩展等支持，底层往往会使用某种存储引擎
// 2. 存储引擎则是小而精, 纯粹专注于单机的读/写/存储, 是用来形容数据库表的 !!

// MySQL底层的四种存储引擎
// 1. Memory存储引擎
// 2. Archive存储引擎
// 3. MyISAM存储引擎
// 4. InnoDB存储引擎
public class InnoDBBasic {

    // MyISAM存储引擎
    //    一个表的存储文件: db.frm(存表结构)，db.MYD(存数据)，db.MYI(存索引, B+树的组织结构)
    //    Select * from where col1=30;
    //    > 如果col1是索引，则先从.MYI文件中找到指定行的磁盘文件地址
    //    > 使用查找到的文件地址，在db.MYD文件中找到指定的数据内容
    //    TODO: 什么是非聚集索引(非聚簇索引, 稀疏索引)? 叶子结点存储的是树对应的磁盘文件地址，Index和data是分开在两个文件中

    // InnoDB存储引擎: MySQL标配，支撑事务，行锁...
    //    一个表的存储文件: db.frm(存表结构), db.ibd(同时存数据+索引)
    //    直接用B+树来组织数据，直接在叶子结点位置存储data数据，而不是磁盘地址
    //    TODO: 什么是聚集索引(聚簇索引)? 叶子结点包含完整的数据结构; 索引的数据和表中存储的实际数据放在一起

    // TODO: 为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键 ? ===> 避免使用UUID(非整型，非自增)
    // 1. 因为数据需要通过B+树来组织数据来存储，如果没有设置主键，则会找一列数据不重复的列(列unique唯一)来组织，如果都没有找到则会建一列隐藏列RowId !!
    //    主键索引: 所设置的primary key就是B+树中的key索引
    // 2. 整型: 减少存储的空间，同时比字符串大小比较效率更高
    // 3. 自增: 为了保证有序性，如果要在一个页已经插满的情况下(>16KB)，插入中间值会导致页分裂或者再左平衡，效率降低
    //         如果自增，永远在后面添加元素，不会导致页分裂

    // TODO: InnoDB存储引擎是如何实现读/写/存储，IO交互，双写缓存 ?
    // 1. "Innodb_page_size" 页的设计作用 ?
    //    Page(C语言实现)是InnoDB在存储数据的最小基本单位, 默认是16KB，是磁盘读交互(I/O)的数据单位量，用
    //    设计Page是为了减少IO交互的次数，提升性能

    // 2. 如何将InnoDB Page页的数据(16KB)从内存flush到磁盘中 / 操作系统页持久化的最小单位是4KB
    //    一共分4次写，如果在写的过程中OS挂了，造成磁盘中的数据没改完 !!
    //    2.1 同样分四次将16KB先写到DoubleWrite Buffer Files中，进行持久化
    //        如果写的过程中DoubleWrite Buffer，可以通过t1表空间+redo log来恢复原来内存中的page页数据
    //    2.2 如果成功，再分四次写到t1表空间，如果在写的过程中OS挂了
    //        再通过DoubleWrite Buffer中的持久化数据来将数据页写完成
    //    随着磁盘的优化，如果能够支撑16KB原子性的写，则不再需要DoubleWrite Buffer Files

    // 3. InnoDB如何使用Page页(16KB)来存储数据 ?
    //    页目录(索引)  在用户数据区域
    //      1         (1,1,1,1,'a')  <-- 插入一行的数据，根据主键在插入的时候有顺序的存储
    //      4         (4,3,1,1,'d')  <-- 影响插入的性能，提高查询的性能(有序的链表，遍历还是慢)
    //                (8,8,2,1,'f')
    //                ....           <-- 插满之后，再在其中插入，则会导致"分页"

    // 4. Change Buffer插入缓冲区 -> 写缓冲区
    //    在执行update的时候，除了更新数据页，还需要更新索引页(聚集索引)
    //    存储修改信息"update 语句"，没有直接去更新索引页，没有直接将索引页加载到内存中
    //    当要走索引的时候，需要从磁盘中取索引页，再结合change buffer得到最新的索引数据
    //    将索引页的更新延迟到非用不可的时候，才做更新，以此可以保证update的性能 !!
}
